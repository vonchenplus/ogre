void SGX_BlendWeight(in float blendWgt, in float2x4 dualQuaternion, out float2x4 vOut)
{
	vOut = blendWgt*dualQuaternion;
}

void SGX_BlendWeight(in float blendWgt, in float3x4 scaleShearMatrix, out float3x4 vOut)
{
	vOut = blendWgt*scaleShearMatrix;
}

void SGX_AntipodalityAdjustment(in float2x4 dq0, in float2x4 dq1, out float2x4 dq2)
{
	//Accurate antipodality handling. For speed increase, remove the following line, 
	//though, the results will only be valid for rotations less than 180 degrees.
	dq2 = (dot(dq0[0], dq1[0]) < 0.0) ? dq1 * -1.0 : dq1;
}

void SGX_CalculateBlendPosition(in float3 position, in float2x4 blendDQ, out float4 vOut)
{
	float3 blendPosition = position + 2.0*cross(blendDQ[0].yzw, cross(blendDQ[0].yzw, position) + blendDQ[0].x*position);
	float3 trans = 2.0*(blendDQ[0].x*blendDQ[1].yzw - blendDQ[1].x*blendDQ[0].yzw + cross(blendDQ[0].yzw, blendDQ[1].yzw));
	blendPosition += trans;

	vOut = float4(blendPosition, 1.0);
}

void SGX_CalculateBlendNormal(in float3 vIn, in float2x4 blendDQ, out float3 vOut)
{
	vOut = (vIn + 2.0*cross(blendDQ[0].yzw, cross(blendDQ[0].yzw, vIn) + blendDQ[0].x*vIn));
}

void SGX_NormalizeDualQuaternion(inout float2x4 dq)
{
	dq /= length(dq[0]);
}

void SGX_AdjointTransposeMatrix(in float3x4 M, out float3x3 vOut)
{
	float3x3 atM;
	atM._m00 = M._m22 * M._m11 - M._m12 * M._m21;
	atM._m01 = M._m12 * M._m20 - M._m10 * M._m22;
	atM._m02 = M._m10 * M._m21 - M._m20 * M._m11;

	atM._m10 = M._m02 * M._m21 - M._m22 * M._m01;
	atM._m11 = M._m22 * M._m00 - M._m02 * M._m20;
	atM._m12 = M._m20 * M._m01 - M._m00 * M._m21;

	atM._m20 = M._m12 * M._m01 - M._m02 * M._m11;
	atM._m21 = M._m10 * M._m02 - M._m12 * M._m00;
	atM._m22 = M._m00 * M._m11 - M._m10 * M._m01;

	vOut = atM;
}

void SGX_BuildDualQuaternionMatrix(in float4 r1, in float4 r2, out float2x4 vOut)
{
	vOut = float2x4(r1, r2);
}