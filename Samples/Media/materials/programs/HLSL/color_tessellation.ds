Texture2D g_baseTexture0 : register( t0 );
SamplerState g_samLinear0 : register( s0 );

Texture2D g_baseTexture1 : register( t1 );
SamplerState g_samLinear1 : register( s1 );

/////////////
// GLOBALS //
/////////////

cbuffer MatrixBuffer
{
    matrix worldviewprojMatrix;
    matrix worldMatrix;
    matrix viewMatrix;
    matrix projectionMatrix;
	float4 cameraPosition;
	float  fDisplacementScale;
};


//////////////
// TYPEDEFS //
//////////////
struct ConstantOutputType
{
    float edges[3]  : SV_TessFactor;
    float inside 	: SV_InsideTessFactor;
	
	// Geometry cubic generated control points
    float3 f3B210    : POSITION3;
    float3 f3B120    : POSITION4;
    float3 f3B021    : POSITION5;
    float3 f3B012    : POSITION6;
    float3 f3B102    : POSITION7;
    float3 f3B201    : POSITION8;
    float3 f3B111    : CENTER;
    
    // Normal quadratic generated control points
    float3 f3N110    : NORMAL3;      
    float3 f3N011    : NORMAL4;
    float3 f3N101    : NORMAL5;
};

struct HullOutputType
{
    float3 position : POSITION;
    float2 texCoord : TEXCOORD0;
    float3 normal 	: TEXCOORD1;
};

//The output of the domain shader goes to the pixel shader. This was previously in the vertex shader.
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 texCoord : TEXCOORD0;
    float3 normal 	: TEXCOORD1;
};

//The inputs to the domain shader are the outputs from the hull shader and constant function.
////////////////////////////////////////////////////////////////////////////////
// Domain Shader
////////////////////////////////////////////////////////////////////////////////
[domain("tri")]
PixelInputType color_tessellation_ds(ConstantOutputType input, float3 barycentricCoordinates : SV_DomainLocation, const OutputPatch<HullOutputType, 3> patch)
{
    float3 vertexPosition;
    PixelInputType output;
	
	 // The barycentric coordinates
    float fU = barycentricCoordinates.x;
    float fV = barycentricCoordinates.y;
    float fW = barycentricCoordinates.z;

    // Precompute squares and squares * 3 
    float fUU = fU * fU;
    float fVV = fV * fV;
    float fWW = fW * fW;
    float fUU3 = fUU * 3.0f;
    float fVV3 = fVV * 3.0f;
    float fWW3 = fWW * 3.0f;
 

    // Compute position from cubic control points and barycentric coords
    vertexPosition = 	patch[0].position * fWW * fW +
						patch[1].position * fUU * fU +
						patch[2].position * fVV * fV +
						input.f3B210 * fWW3 * fU +
						input.f3B120 * fW * fUU3 +
						input.f3B201 * fWW3 * fV +
						input.f3B021 * fUU3 * fV +
						input.f3B102 * fW * fVV3 +
						input.f3B012 * fU * fVV3 +
						input.f3B111 * 6.0f * fW * fU * fV;
					 
	// Compute normal from quadratic control points and barycentric coords
    float3 f3Normal = 	patch[0].normal * fWW +
                        patch[1].normal * fUU +
                        patch[2].normal * fVV +
                        input.f3N110 * fW * fU +
                        input.f3N011 * fU * fV +
                        input.f3N101 * fW * fV;
					 
	// Normalize the interpolated normal    
    f3Normal = normalize( f3Normal );
    
	output.texCoord = patch[0].texCoord * fW + patch[1].texCoord * fU + patch[2].texCoord * fV;
		
	output.position = mul( worldviewprojMatrix, float4(vertexPosition, 1.0f) );
	output.normal = f3Normal;

    return output;
}