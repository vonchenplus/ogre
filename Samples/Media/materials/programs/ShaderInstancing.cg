//---------------------------------------------------------------------------
//These materials/shaders are part of the NEW InstanceManager implementation
//Written by Matias N. Goldberg ("dark_sylinc")
//---------------------------------------------------------------------------

//---------------------------------------------
//Vertex Shader Input
//---------------------------------------------
struct VS_INPUT
{
	float4 Position	:	POSITION;
	float3 Normal	:	NORMAL;
	float3 Tangent	:	TANGENT;
	float2 uv0	:	TEXCOORD0;

	float4 BlendIdx	:	BLENDINDICES;
	float4 BlendWgt	:	BLENDWEIGHT;
};

#include "InstancingVertexInterpolators.cg"
#ifdef ST_DUAL_QUATERNION
//#include "DualQuaternion_Common.cg"

float3x3 adjointTransposeMatrix(float3x3 M)
{
	float3x3 atM;
	atM._m00 = M._m22 * M._m11 - M._m12 * M._m21;
	atM._m01 = M._m12 * M._m20 - M._m10 * M._m22;
	atM._m02 = M._m10 * M._m21 - M._m20 * M._m11;

	atM._m10 = M._m02 * M._m21 - M._m22 * M._m01;
	atM._m11 = M._m22 * M._m00 - M._m02 * M._m20;
	atM._m12 = M._m20 * M._m01 - M._m00 * M._m21;

	atM._m20 = M._m12 * M._m01 - M._m02 * M._m11;
	atM._m21 = M._m10 * M._m02 - M._m12 * M._m00;
	atM._m22 = M._m00 * M._m11 - M._m10 * M._m01;

	return atM;
}
#endif

//---------------------------------------------
//Main Vertex Shader
//---------------------------------------------
VS_OUTPUT main_vs( in VS_INPUT input,
				   uniform float4x4 viewProjMatrix,
#ifdef ST_DUAL_QUATERNION
				   uniform float2x4 worldDualQuaternion2x4Array[48],
				   uniform float3x4 scaleM[48]
#else
				   uniform float3x4 worldMatrix3x4Array[80]
#endif
#if defined( DEPTH_SHADOWCASTER ) || defined( DEPTH_SHADOWRECEIVER )
				,  uniform float4 depthRange
#endif
#ifdef DEPTH_SHADOWRECEIVER
				,  uniform float4x4 texViewProjMatrix
#endif
				   )
{
	VS_OUTPUT output;

	float4 worldPos	 = 0;
	float3 worldNorm = 0;

	int idx = int(input.BlendIdx[0]);
#ifdef ST_DUAL_QUATERNION
	//First phase - applies scaling and shearing:
	float3x4 blendS = scaleM[idx];
		
	float3 pass1_position = mul(blendS, input.Position);
	float3x3 blendSrotAT = adjointTransposeMatrix(float3x3(blendS));
	float3 pass1_normal = normalize(mul(blendSrotAT, input.Normal.xyz));

	//Only dealing with one weight so normalization of the dual quaternion and weighting are unnecessary
	float2x4 blendDQ = worldDualQuaternion2x4Array[idx];
	float3 blendPosition = pass1_position.xyz + 2.0*cross(blendDQ[0].yzw, cross(blendDQ[0].yzw, pass1_position.xyz) + blendDQ[0].x*pass1_position.xyz);
	float3 trans = 2.0*(blendDQ[0].x*blendDQ[1].yzw - blendDQ[1].x*blendDQ[0].yzw + cross(blendDQ[0].yzw, blendDQ[1].yzw));
	blendPosition += trans;
	worldPos = float4(blendPosition, 1.0);
	worldNorm = pass1_normal + 2.0*cross(blendDQ[0].yzw, cross(blendDQ[0].yzw, pass1_normal) + blendDQ[0].x*pass1_normal);
#else
	worldPos  = float4( mul( worldMatrix3x4Array[idx], input.Position ).xyz, 1.0f );
	worldNorm = mul( (float3x3)(worldMatrix3x4Array[idx]), input.Normal );
#endif

	/*int i;
	for( i=0; i<4; i++ )
	{
		int idx = int(input.BlendIdx[0]);
		worldPos += float4( mul( worldMatrix3x4Array[idx], input.Position ).xyz, 1.0f ) * input.BlendWgt[i];
		worldNorm += mul( (float3x3)(worldMatrix3x4Array[idx]), input.Normal ) * input.BlendWgt[i];
	}*/

	//Transform the position
	output.Position		= mul( viewProjMatrix, worldPos );
	
#ifdef DEPTH_SHADOWCASTER
	output.ps.unused	= float3( 0 );
	output.ps.depth		= (output.Position.z - depthRange.x + SHADOW_BIAS) * depthRange.w;
#else
	output.ps.uv0		= input.uv0;
	
	//Pass Normal and position for Blinn Phong lighting
	output.ps.Normal	= normalize(worldNorm);
	output.ps.vPos		= worldPos.xyz;

	#ifdef DEPTH_SHADOWRECEIVER
		// Calculate the position of vertex in light space to do shadows
		output.ps.lightSpacePos = mul( texViewProjMatrix, worldPos );
		// make linear
		output.ps.lightSpacePos.z = (output.ps.lightSpacePos.z - depthRange.x) * depthRange.w;
	#endif
#endif

	return output;
}
